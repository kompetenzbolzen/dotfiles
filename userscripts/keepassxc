#!/usr/bin/env python3

# Copyright (c) 2018-2021 Markus Bl√∂chl <ususdei@gmail.com>
# Copyright (c) 2025 Jonas Gunz <himself@jonasgunz.de>
#
# SPDX-License-Identifier: GPL-3.0-or-later

"""
# Introduction

This is a [qutebrowser][2] [userscript][5] to fill website credentials from a [KeepassXC][1] password database.


# Installation

First, you need to enable [KeepassXC-Browser][6] extensions in your KeepassXC config.


Third, install the python module `pynacl`.


Finally, adapt your qutebrowser config.
You can e.g. add the following lines to your `~/.config/qutebrowser/config.py`

```python
config.bind('<Alt-Shift-u>', 'spawn --userscript qute-keepassxc', mode='insert')
config.bind('pw', 'spawn --userscript keepassxc', mode='normal')
```

To manage multiple accounts you also need [rofi](https://github.com/davatorium/rofi) installed.

# Usage

If you are on a webpage with a login form, simply activate one of the configured key-bindings.

The first time you run this script, KeepassXC will ask you for authentication like with any other browser extension.
Just provide a name of your choice and accept the request if nothing looks fishy.


# How it works

This script will talk to KeepassXC using the native [KeepassXC-Browser protocol][4].

This script needs to store the key used to associate with your KeepassXC instance somewhere.
Unlike most browser extensions which only use plain local storage, this one attempts to do so in a safe way
by storing the key in encrypted form using GPG.
Therefore you need to have a public-key-pair readily set up.

GPG might then ask for your private-key password whenever you query the database for login credentials.


# TOTP

This script recently received experimental TOTP support.
To use it, you need to have working TOTP authentication within KeepassXC.
Then call `qute-keepassxc` with the `--totp` flags.

For example, I have the following line in my `config.py`:

```python
config.bind('pt', 'spawn --userscript keepassxc --totp', mode='normal')
```

For now this script will simply insert the TOTP-token into the currently selected
input field, since I have not yet found a reliable way to identify the correct field
within all existing login forms.
Thus you need to manually select the TOTP input field, press escape to leave input
mode and then enter `pt` to fill in the token (or configure another key-binding for
insert mode if you prefer that).


[1]: https://keepassxc.org/
[2]: https://qutebrowser.org/
[3]: https://gnupg.org/
[4]: https://github.com/keepassxreboot/keepassxc-browser/blob/develop/keepassxc-protocol.md
[5]: https://github.com/qutebrowser/qutebrowser/blob/main/doc/userscripts.asciidoc
[6]: https://keepassxc.org/docs/KeePassXC_GettingStarted.html#_setup_browser_integration
"""

import sys
import os
import socket
import json
import base64
import subprocess
import argparse

import nacl.utils
import nacl.public


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Full passwords from KeepassXC")
    parser.add_argument('url', nargs='?', default=os.environ.get('QUTE_URL'))
    parser.add_argument('--totp', action='store_true',
                        help="Fill in current TOTP field instead of username/password")
    parser.add_argument('--socket', '-s', default='/run/user/{}/org.keepassxc.KeePassXC.BrowserServer'.format(os.getuid()),
                        help='Path to KeepassXC browser socket')
    return parser.parse_args()

def qute(cmd):
    with open(os.environ['QUTE_FIFO'], 'w') as fifo:
        fifo.write(cmd)
        fifo.write('\n')
        fifo.flush()

def error(msg):
    print(msg, file=sys.stderr)
    qute('message-error "{}"'.format(msg))

def info(msg):
    print(msg, file=sys.stderr)
    qute('message-info "{}"'.format(msg))

class KeepassError(Exception):
    def __init__(self, code, desc):
        self.code = code
        self.description = desc

    def __str__(self):
        return f"KeepassXC Error [{self.code}]: {self.description}"

class KeepassXCDatabase:
    def __init__(self, socket_path: str):
        self._sock         = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self._socket_path  = socket_path
        self._client_key   = nacl.public.PrivateKey.generate()
        self._client_nonce = base64.b64encode(
                nacl.utils.random(nacl.public.Box.NONCE_SIZE)
            ).decode('utf-8')
        self.cryptobox: nacl.public.Box

    def connect(self) -> None:
        self._init_socket()
        self._perform_key_exchange()

    def _perform_key_exchange(self) -> None:
        self._send_raw_msg(dict(
            action    = 'change-public-keys',
            publicKey = base64.b64encode(self._client_key.public_key.encode()).decode('utf-8'),
            nonce     = base64.b64encode(nacl.utils.random(nacl.public.Box.NONCE_SIZE)).decode('utf-8'),
            clientID  = self._client_nonce
        ))

        resp = self._recv_raw_msg()
        # TODO ugly assters
        assert resp['action'] == 'change-public-keys'
        assert resp['success'] == 'true'
        assert resp['nonce']
        self.cryptobox = nacl.public.Box(
            self._client_key,
            nacl.public.PublicKey(base64.b64decode(resp['publicKey']))
        )

    def _init_socket(self) -> None:
        if not os.path.exists(self._socket_path):
            raise KeepassError(-1, "KeepassXC Browser socket does not exists")
        self._sock.connect(self._socket_path)

    def _send_raw_msg(self, msg : dict | list) -> None:
        self._sock.send( json.dumps(msg).encode('utf-8') )

    def _recv_raw_msg(self) -> dict:
        return json.loads( self._sock.recv(4096).decode('utf-8') )

    def authenticate(self, key: nacl.public.PrivateKey, id: str) -> bool:
        self.send_msg(dict(
            action = 'test-associate',
            id     = id,
            key    = base64.b64encode(key.public_key.encode()).decode('utf-8')
        ), triggerUnlock = 'true')
        return self.recv_msg()['success'] == 'true'

    def associate(self, key: nacl.public.PrivateKey) -> str:
        self.send_msg(dict(
            action = 'associate',
            key    = base64.b64encode(self._client_key.public_key.encode()).decode('utf-8'),
            idKey  = base64.b64encode(key.public_key.encode()).decode('utf-8')
        ))
        resp = self.recv_msg()
        return resp['id']

    def send_msg(self, msg: dict, **extra ) -> None:
        nonce = nacl.utils.random(nacl.public.Box.NONCE_SIZE)
        self._send_raw_msg(dict(
            action   = msg['action'],
            message  = base64.b64encode(
                self.cryptobox.encrypt(json.dumps(msg).encode('utf-8'), nonce).ciphertext)
                .decode('utf-8'),
            nonce    = base64.b64encode(nonce).decode('utf-8'),
            clientID = self._client_nonce,
            **extra
        ))

    def recv_msg(self) -> dict:
        resp = self._recv_raw_msg()
        if 'error' in resp:
            raise KeepassError(resp['errorCode'], resp['error'])
        assert resp['action']
        return json.loads(
                self.cryptobox.decrypt(base64.b64decode(resp['message']),
                                       base64.b64decode(resp['nonce']))
                    .decode('utf-8'))


class KeepassXC:
    def __init__(self, socket_path):
        self._db      = KeepassXCDatabase(socket_path)
        self._ass_man = SecretAssociationManager()

    def connect(self):
        self._db.connect()

        if not self._ass_man.association_exists():
            info("Client is not associated")
            self._ass_man.association_store(
                self._db.associate( self._ass_man.key_get() )
            )

        self._db.authenticate(self._ass_man.key_get(), self._ass_man.association_get())


    # WARNING not sure
    def get_databasehash(self) -> str:
        self._db.send_msg(dict(action='get-databasehash'))
        return self._db.recv_msg()['hash']

    # TODO heck if we need this.
    def lock_database(self) -> bool:
        self._db.send_msg(dict(action='lock-database'))
        try:
            self._db.recv_msg()
        except KeepassError as e:
            if e.code == 1:
                return True
            raise
        return False

    def get_logins(self, url: str) -> dict:
        self._db.send_msg(dict(
            action = 'get-logins',
            url    = url,
            keys   = [{
                'id': self._ass_man.association_get(),
                'key': base64.b64encode(self._ass_man.key_get().public_key.encode()).decode('utf-8')
            }]
        ))
        return self._db.recv_msg()['entries']

    # TODO typehint
    def get_totp(self, uuid):
        self._db.send_msg(dict(
            action = 'get-totp',
            uuid = uuid
        ))
        response = self._db.recv_msg()
        if response['success'] != 'true' or not response['totp']:
            return None
        return response['totp']

def secret_exists(*args: str) -> bool:
    return subprocess.run(
                ['secret-tool', 'lookup', *args],
                stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
                ).returncode == 0


def secret_store(value: str, label: str, *args: str) -> None:
    subprocess.run(
        ['secret-tool', 'store', '--label', label, *args],
        input=value, text=True
    )


def secret_get(*args: str) -> str:
    return subprocess.run(
              ['secret-tool', 'lookup', *args],
              capture_output=True, text=True).stdout


class AssociationManager:
    def __init__(self):
        if not self._key_exists():
            self._key_generate()

    def key_get(self) -> nacl.public.PrivateKey:
        return nacl.public.PrivateKey.from_seed( self._key_get() )

    def _key_generate(self) -> None:
        self._key_store(nacl.utils.random(32))

    def association_exists(self) -> bool:
        raise Exception
    def association_get(self) -> str:
        raise Exception
    def association_store(self, value: str) -> None:
        raise Exception
    def _key_exists(self) -> bool:
        raise Exception
    def _key_get(self) -> bytes:
        raise Exception
    def _key_store(self, key: bytes) -> None:
        raise Exception


class SecretAssociationManager(AssociationManager):
    TAGS = ['app', 'qutebrowser', 'userscript', 'keepassxc']
    def association_exists(self) -> bool:
        return secret_exists(*self.TAGS, 'type', 'id')

    def association_get(self) -> str:
        return secret_get(*self.TAGS, 'type', 'id')

    def association_store(self, value: str) -> None:
        secret_store(value, 'qutebrowser keepassxc id', *self.TAGS, 'type', 'id')

    def _key_exists(self) -> bool:
        return secret_exists(*self.TAGS, 'type', 'key')

    def _key_get(self) -> bytes:
        return base64.b64decode(secret_get(*self.TAGS, 'type', 'key').encode())

    def _key_store(self, key: bytes) -> None:
        secret_store(base64.b64encode(key).decode('utf-8'), 'qutebrowser keepassxc key', *self.TAGS, 'type', 'key')


def make_js_code(username, password):
    return ' '.join("""
        function isVisible(elem) {
            var style = elem.ownerDocument.defaultView.getComputedStyle(elem, null);

            if (style.getPropertyValue("visibility") !== "visible" ||
                style.getPropertyValue("display") === "none" ||
                style.getPropertyValue("opacity") === "0") {
                return false;
            }

            return elem.offsetWidth > 0 && elem.offsetHeight > 0;
        };

        function hasPasswordField(form) {
            var inputs = form.getElementsByTagName("input");
            for (var j = 0; j < inputs.length; j++) {
                var input = inputs[j];
                if (input.type === "password") {
                    return true;
                }
            }
            return false;
        };

        function loadData2Form (form) {
            var inputs = form.getElementsByTagName("input");
            for (var j = 0; j < inputs.length; j++) {
                var input = inputs[j];
                if (isVisible(input) && (input.type === "text" || input.type === "email")) {
                    input.focus();
                    input.value = %s;
                    input.dispatchEvent(new Event('input', { 'bubbles': true }));
                    input.dispatchEvent(new Event('change', { 'bubbles': true }));
                    input.blur();
                }
                if (input.type === "password") {
                    input.focus();
                    input.value = %s;
                    input.dispatchEvent(new Event('input', { 'bubbles': true }));
                    input.dispatchEvent(new Event('change', { 'bubbles': true }));
                    input.blur();
                }
            }
        };

        function fillFirstForm() {
            var forms = document.getElementsByTagName("form");
            for (i = 0; i < forms.length; i++) {
                if (hasPasswordField(forms[i])) {
                    loadData2Form(forms[i]);
                    return;
                }
            }
            alert("No Credentials Form found");
        };

        fillFirstForm()
    """.splitlines()) % (json.dumps(username), json.dumps(password))


def make_js_totp_code(totp):
    return ' '.join("""
        (function () {
            var input = document.activeElement;
            if (!input || input.tagName !== "INPUT") {
                alert("No TOTP input field selected");
                return;
            }
            input.value = %s;
            input.dispatchEvent(new Event('input', { 'bubbles': true }));
            input.dispatchEvent(new Event('change', { 'bubbles': true }));
        })();
    """.splitlines()) % (json.dumps(totp),)

# TODO generic dmenu provider?
def select_account(creds: dict) -> dict | None:
    try:
        if len(creds) == 1:
            return creds[0]
        idx = subprocess.check_output(
                ['rofi', '-dmenu', '-format', 'i', '-matching', 'fuzzy',
                '-p', 'Search',
                '-mesg', '<b>qute-keepassxc</b>: select an account, please!'],
                input=b"\n".join(c['login'].encode('utf-8') for c in creds)
        )
        idx = int(idx)
        if idx < 0:
            return None
        return creds[idx]
    except subprocess.CalledProcessError:
        return None
    except FileNotFoundError:
        error("rofi not found. Please install rofi to select from multiple credentials")
        return creds[0]
    except Exception as e:
        error(f"Error while picking account: {e}")
        return None

def main():
    if 'QUTE_FIFO' not in os.environ:
        print(f"No QUTE_FIFO found - {sys.argv[0]} must be run as a qutebrowser userscript")
        sys.exit(-1)

    args = parse_args()
    assert args.url, "Missing URL"

    kp = KeepassXC(args.socket)
    kp.connect()

    creds = kp.get_logins(args.url)
    if not creds:
        error('No credentials found')
        return

    cred = select_account(creds)
    if not cred:
        error('No credentials selected')
        return

    if args.totp:
        uuid = cred['uuid']
        totp = kp.get_totp(uuid)
        if not totp:
            error('No TOTP key found')
            return
        qute('jseval -q ' + make_js_totp_code(totp))
    else:
        name, pw = cred['login'], cred['password']
        if name and pw:
            qute('jseval -q ' + make_js_code(name, pw))


if __name__ == '__main__':
    try: main()
    except Exception as e: error(str(e))

